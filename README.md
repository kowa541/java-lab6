Задание 1. Аннотации
1 @Invoke. 
Разработайте аннотацию @Invoke, со следующими характеристиками:
• Целью может быть только МЕТОД
• Доступна во время исполнения программы
• Не имеет свойств
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них 
аннотацией @Invoke.
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные 
аннотацией @Invoke, и вызывает их автоматически.

2 @Default. 
Разработайте аннотацию @Default, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет обязательное свойство value типа Class
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.
Напишите обработчик, который выводит имя указанного класса по умолчанию.

3 @ToString.
Разработайте аннотацию @ToString, со следующими характеристиками:
• Целью может быть ТИП или ПОЛЕ
• Доступна во время исполнения программы
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO
• Значение свойства по умолчанию: YES
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).
Создайте метод, который формирует строковое представление объекта, учитывая только те поля, 
где @ToString имеет значение YES.

4 @Validate. 
Разработайте аннотацию @Validate, со следующими характеристиками:
• Целью может быть ТИП или АННОТАЦИЯ
• Доступна во время исполнения программы
• Имеет обязательное свойство value, типа Class[]
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.

5 @Two.
Разработайте аннотацию @Two, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет два обязательных свойства: first типа String и second типа int
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.
Реализуйте обработчик, который считывает и выводит значения этих свойств.

6 @Cache. 
Разработайте аннотацию @Cache, со следующими характеристиками:
• Целью может быть ТИП
• Доступна во время исполнения программы
• Имеет необязательное свойство value, типа String[]
• Значение свойства по умолчанию: пустой массив
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что 
список пуст.

Описание решения
1. Аннотация @Invoke
Цель: METHOD
Удержание: RUNTIME
Свойства: отсутствуют
Реализация:
Создан класс InvokeExample с методом doSomething(), помеченным @Invoke.
Обработчик invokeAnnotatedMethods() ищет такие методы через Reflection и вызывает их.

2. Аннотация @Default
Цель: TYPE, FIELD
Свойство: Class<?> value()
Реализация:
Класс DefaultExample аннотирован как @Default(String.class).
Обработчик выводит имя указанного класса.

3. Аннотация @ToString
Цель: TYPE, FIELD
Свойство: Mode value() default Mode.YES (где Mode — enum с YES/NO)
Реализация:
Класс ToStringExample содержит поля с разными значениями аннотации.
Метод buildToString() формирует строку, включая только поля с Mode.YES.

4. Аннотация @Validate
Цель: TYPE, ANNOTATION_TYPE
Свойство: Class<?>[] value()
Реализация:
Класс ValidateExample аннотирован списком: String.class, Integer.class, ArrayList.class.
Обработчик выводит упрощённые имена классов.

5. Аннотация @Two
Цель: TYPE
Свойства: String first(), int second()
Реализация:
Класс TwoExample аннотирован как @Two(first = "Laboratory", second = 6).
Добавлен метод validateTwoAnnotation(), который проверяет:
first не пустой,
second >= 0.

6. Аннотация @Cache
Цель: TYPE
Свойство: String[] value() default {}
Реализация:
Класс CacheExample аннотирован как @Cache({"users", "sessions", "profiles"}).
Обработчик выводит список или сообщение «список пуст».

Задание 2. Тестирование

2 Создайте тест, используя фреймворк JUnit, который проверяет корректность вызова методов, 
отмеченных аннотацией @Invoke.
• Использовать Reflection API для поиска методов с аннотацией.
• Убедиться, что метод действительно выполняется без исключений.
• Проверить, что возвращаемое значение или побочный эффект соответствует ожиданиям 
(например, устанавливает флаг или изменяет состояние объекта).
• Тест должен использовать аннотацию @BeforeEach для подготовки тестируемого 
экземпляра класса.

6. Разработайте тест, используя фреймворк JUnit, проверяющий корректность обработки 
аннотации @Two, если её свойства заданы некорректно. Например, строковое свойство first пустое
(""), а числовое second отрицательное.
• Создайте вспомогательный класс с аннотацией @Two(first = "", second = -1).
• В тесте реализуйте метод, который через Reflection считывает значения аннотации.
• Если одно из свойств нарушает ожидаемые условия (first – пустая строка, second < 0), то 
должен быть выброшен IllegalArgumentException.
• Используйте assertThrows() из JUnit для проверки выбрасываемого исключения.

2.2 Тест для @Invoke
Создан класс InvokeTestSubject с флагом wasInvoked.
Метод с @Invoke устанавливает флаг в true.
Тест InvokeAnnotationTest:
подготавливает объект через @BeforeEach,
вызывает метод через Reflection,
проверяет, что флаг стал true с помощью assertTrue().

2.6 Тест для @Two (валидация некорректных данных)
Создан класс TwoInvalidExample с @Two(first = "", second = -1).
Тест TwoAnnotationValidationTest:
вызывает validateTwoAnnotation(TwoInvalidExample.class),
ожидает IllegalArgumentException через assertThrows().
